---
title: 二叉树
description: 前中后序遍历、递归与迭代，LeetCode 树题基础
---

# 二叉树

LeetCode 树题大多基于**二叉树的遍历**和**递归定义**。先掌握前/中/后序和层序，再练递归写法和常见题型。

## 节点定义

树节点通常带 `val`、`left`、`right`；题目会给这种结构或数组（按层序存）。

<PythonPlayground code={`class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

# 小树：  1
#       / \
#      2   3
root = TreeNode(1)
root.left = TreeNode(2)
root.right = TreeNode(3)
print(root.val, root.left.val, root.right.val)   # 1 2 3`} />

## 前序、中序、后序（递归）

前序：根 → 左 → 右；中序：左 → 根 → 右；后序：左 → 右 → 根。递归写法最直观。

<PythonPlayground code={`def preorder(root):
    if not root:
        return []
    return [root.val] + preorder(root.left) + preorder(root.right)

def inorder(root):
    if not root:
        return []
    return inorder(root.left) + [root.val] + inorder(root.right)

def postorder(root):
    if not root:
        return []
    return postorder(root.left) + postorder(root.right) + [root.val]

# 树: 1(2,3) 即 1 的左右为 2,3
root = TreeNode(1, TreeNode(2), TreeNode(3))
print("前序", preorder(root))   # [1, 2, 3]
print("中序", inorder(root))     # [2, 1, 3]
print("后序", postorder(root))   # [2, 3, 1]`} />

## 层序遍历（BFS）

用队列，每次处理一层，LeetCode 很多「按层」的题都用这个。

<PythonPlayground code={`from collections import deque

def level_order(root):
    if not root:
        return []
    q = deque([root])
    result = []
    while q:
        level = []
        for _ in range(len(q)):
            node = q.popleft()
            level.append(node.val)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        result.append(level)
    return result

root = TreeNode(1, TreeNode(2), TreeNode(3))
root.left.left = TreeNode(4)
print(level_order(root))   # [[1], [2, 3], [4]]`} />

## 树高与判断平衡

树高递归：`height = 1 + max(left_h, right_h)`；平衡即左右高差 ≤ 1 且左右子树都平衡。

<PythonPlayground code={`def height(root):
    if not root:
        return 0
    return 1 + max(height(root.left), height(root.right))

def is_balanced(root):
    if not root:
        return True
    lh, rh = height(root.left), height(root.right)
    if abs(lh - rh) > 1:
        return False
    return is_balanced(root.left) and is_balanced(root.right)

root = TreeNode(1, TreeNode(2), TreeNode(3))
print(height(root))           # 2
print(is_balanced(root))      # True`} />

## 小结

- **遍历**：前/中/后序用递归或栈，层序用队列。
- **递归**：先想「当前节点做什么」「左右子树返回什么」再写边界 `if not root`。
- 很多题是「遍历 + 在遍历过程中记录/判断」（如最大深度、路径和、镜像等）。
