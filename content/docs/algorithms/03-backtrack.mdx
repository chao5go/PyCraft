---
title: 回溯（Backtracking）
description: 枚举、剪枝、恢复状态，排列组合与子集
---

# 回溯（Backtracking）

用**递归 + 枚举**试遍所有可能，走不通就**回退**（恢复状态），常配合**剪枝**减少无效分支。排列、组合、子集、棋盘类题常用。

## 思路

1. **选择**：当前步有哪些选项（例如选哪个数、放哪一列）。
2. **递归**：做一种选择后进入下一层。
3. **撤销**：退回当前层时**恢复状态**，再试下一个选项。

## 子集（无重）

求数组的所有子集（2^n 个）。每次递归「选或不选」当前元素，到末尾时把当前路径加入结果。

<PythonPlayground code={`def subsets(nums):
    result = []
    path = []
    def dfs(i):
        if i == len(nums):
            result.append(path[:])
            return
        path.append(nums[i])
        dfs(i + 1)
        path.pop()
        dfs(i + 1)
    dfs(0)
    return result

print(subsets([1, 2]))   # [[1, 2], [1], [2], []]`} />

## 全排列（无重）

求数组的全排列。用 `used` 记哪些已选，枚举每个未选数作为当前位，递归后撤销。

<PythonPlayground code={`def permute(nums):
    result = []
    path = []
    used = [False] * len(nums)
    def dfs():
        if len(path) == len(nums):
            result.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            dfs()
            path.pop()
            used[i] = False
    dfs()
    return result

print(permute([1, 2, 3]))   # [[1,2,3], [1,3,2], [2,1,3], ...]`} />

## 组合（选 k 个）

从 n 个数里选 k 个，无重、不计顺序。按「从哪一位开始选」递归，避免重复（只往后选）。

<PythonPlayground code={`def combine(n, k):
    result = []
    path = []
    def dfs(start):
        if len(path) == k:
            result.append(path[:])
            return
        for i in range(start, n + 1):
            path.append(i)
            dfs(i + 1)
            path.pop()
    dfs(1)
    return result

print(combine(4, 2))   # [[1,2], [1,3], [1,4], [2,3], [2,4], [3,4]]`} />

## 小结

- **状态**：当前路径 `path`、已用标记 `used` 等，递归前改、递归后**一定恢复**。
- **剪枝**：不满足条件时 `continue` 或提前 `return`，少走无效分支。
- 子集/排列/组合是回溯的经典形式，很多题是在此基础上加条件（去重、和为 target 等）。
